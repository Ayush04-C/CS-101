\section{Array Powerplay (More Arrays or Recursion?)}
\begin{topics}
Recursion \& arrays and previous sections.
\end{topics}
\subsection{Determinant of a Matrix}
For a matrix $A\in \Z^{n\times n}$ (zero-based indexing) and for a $i\in\{0,1,\ldots,n-1\}$, the determinant of $A$ ($\op{det}(A)$) is
\begin{equation}
% A={\begin{bmatrix}a_{0,0}&a_{0,1}&\cdots &a_{0,n-1}\\a_{1,0}&a_{1,1}&\cdots &a_{1,n-1}\\\vdots &\vdots &\ddots &\vdots \\a_{n-1,0}&a_{n-1,1}&\cdots &a_{n-1,n-1}\end{bmatrix}} \quad \text{ and } \quad 
\det(A)=\sum _{j=0}^{n-1}(-1)^{i+j}a_{ij}M_{ij}%\footnote{This is the popular Laplace Expansion.}
\quad \text{ $M_{ij}$ is the $\op{det}$ of the matrix obtained by removing the $i$\textsuperscript{th} row and $j$\textsuperscript{th} column of $A$.}%$(n-1) \times (n-1)$ 
\end{equation}
\textbf{Problem Statement:}\\
Find the determinant of given matrix $A$ using the above formula (called as Laplace Expansion).
\begin{testcases}
	{$t$ \hfill(number of test cases, an integer)\\$n_i$\hfill(size of matrix $A$)\\$a_{0,0}\quad a_{0,1}\quad \ldots \quad\ a_{0,n_i-1}$\quad\hfill(0\textsuperscript{th} row of matrix)\\$a_{1,0}\quad a_{1,1}\quad \ldots \quad\ a_{1,n_i-1}$\quad \hfill(1\textsuperscript{th} row of matrix)\\$\cdots$\\$a_{n_i-1,0}\quad a_{n_i-1,1}\quad \ldots \quad\ a_{n_i-1,n_i-1}$\hfill($(n_i-1)$\textsuperscript{th} row of matrix)}
	{$\op{det}(A)$\hfill(space seperated integers for each test case)}
	{$1\leq n_i \leq 10, -1000\leq a_{i,j}\leq 1000$\hfill(integers)}
	{5\\1\\7\\2\\4 3\\1 2\\3\\5 4 3\\6 1 2\\7 8 9\\4\\1 1 1 1\\1 3 9 27\\1 6 36 216\\1 10 100 1000\\5\\4 -1 -1 -1 -1\\-1 2 -1 0 0\\-1 -1 2 0 0 \\-1 0 0 2 -1\\-1 0 0 -1 3}
	{7\quad5\quad-72\quad7560\quad9}
	{https://github.com/paramrathour/CS-101/tree/main/Starter Codes/Determinant.cpp}
\end{testcases}
\begin{funvideo}
	\href{https://youtu.be/Cov_kLatdlc}{The Vandermonde Matrix and Polynomial Interpolation -- Dr. Will Wood}
\end{funvideo}
\KOMAoptions{paper=A3}
\recalctypearea
\subsection{Tower of Hanoi}
Tower of Hanoi is a mathematical puzzle with three rods (A,B,C) and n disks on left rod (A) with in decreasing
order of their radius from top to bottom .

The objective of the puzzle is to move the entire stack of disks to the
rightmost rod (C), obeying the following simple rules,
\begin{itemize}
	\item Only one disk can be moved at a time.
	\item Each move consists of taking the upper disk from one of the stacks and placing it on top of another stack; i.e., a disk can only be moved if it is the uppermost disk on a stack.
	\item No disk may be placed on top of a smaller disk.
\end{itemize}
Check any of the linked videos below for more information.
% \begin{figure}[H]
% 	\centering
% 	\includegraphics[width = 0.3\linewidth]{Tower of Hanoi.pdf}
% 	\caption{An example for $n=3$, (\href{https://www.algotree.org/images/Tower_Of_Hanoi.svg}{Image} by \href{https://www.algotree.org/algorithms/recursive/tower_of_hanoi/}{Algotree}}
% 	\label{fig:quicksort}
% \end{figure}
\textbf{Problem Statement:}

For a given $n$, output the sequence of steps to be taken in the following format:

\verb!Disk <disk-number> from <rod-name> to <rod-name>!.

Solve the problem \textbf{with recursion} and \textbf{without recursion} as well :).
\begin{testcasesMore}
	{$t$ \hfill(number of test cases, an integer)\\$n_1\ n_2\ \ldots \ n_t$\hfill($t$ numbers)}
	{Corresponding steps till completetion\hfill(each step on a new line for each test case)}
	{$1\leq n_i \leq 20$\hfill(integers)}
	{4\\1 2 3 4}
	{Disk 1 from A to B\\\\
	Disk 1 from A to C\\
	Disk 2 from A to B\\
	Disk 1 from C to B\\\\
	Disk 1 from A to B\\
	Disk 2 from A to C\\
	Disk 1 from B to C\\
	Disk 3 from A to B\\
	Disk 1 from C to A\\
	Disk 2 from C to B\\
	Disk 1 from A to B\\\\
	Disk 1 from A to C\\
	Disk 2 from A to B\\
	Disk 1 from C to B\\
	Disk 3 from A to C\\
	Disk 1 from B to A\\
	Disk 2 from B to C\\
	Disk 1 from A to C\\
	Disk 4 from A to B\\
	Disk 1 from C to B\\
	Disk 2 from C to A\\
	Disk 1 from B to A\\
	Disk 3 from C to B\\
	Disk 1 from A to C\\
	Disk 2 from A to B\\
	Disk 1 from C to B}
	{https://github.com/paramrathour/CS-101/tree/main/Test Cases/Tower of Hanoi/Input.txt}
	{https://github.com/paramrathour/CS-101/tree/main/Test Cases/Tower of Hanoi/Output.txt}
	{https://github.com/paramrathour/CS-101/tree/main/Starter Codes/Tower of Hanoi.cpp}
\end{testcasesMore}
\begin{funvideo}
	Binary, Hanoi and Sierpinski, \href{https://youtu.be/2SUvWfNJSsM}{part 1}, \href{https://youtu.be/bdMfjfT0lKk}{part 2} -- \href{https://www.youtube.com/@3blue1brown}{3Blue1Brown}\\
	\href{https://youtu.be/rf6uf3jNjbo}{Towers of Hanoi: A Complete Recursive Visualization -- Reducible}\\
	\href{https://youtu.be/MbonokcLbNo}{The ultimate tower of Hanoi algorithm -- Mathologer}
\end{funvideo}
\KOMAoptions{paper=A4}
\recalctypearea
\KOMAoptions{paper=A3}
\recalctypearea
\subsection{Quicksort}
Quicksort is a divide and conquer algorithm like merge sort discused in class. It first divides the input array into two smaller sub-arrays: the low elements and the high elements. It then
recursively sorts the sub-arrays. Precisely,
\begin{itemize}
	\item Pick an element, called a pivot, from the array.
	\item Reorder the array so that all elements with values less than the pivot come before the pivot, while all elements with values greater than the pivot come after it (equal values can go either way). After this \emph{partitioning}, the pivot is in its final position (relative to other elements).
	\item Recursively apply the above steps to the sub-array of elements with smaller values and separately to the sub-array of elements with greater values. The base case of the recursion are arrays of size zero or one, which are in order by definition, so they never need to be sorted.
\end{itemize}
\begin{note}
	The pivot selection and partitioning steps can be done in several different ways; the algorithm's performance greatly varies with implementation schemes.
\end{note}
\begin{figure}[H]
	\centering
	\includegraphics[width = 0.3\linewidth]{Quicksort.pdf}
	\caption{Quicksort Runthrough (\href{https://commons.wikimedia.org/wiki/File:Quicksort-diagram.svg}{Image} by \href{https://commons.wikimedia.org/wiki/User:Znupi}{Znupi}, Public domain, via Wikimedia Commons)}
	\label{fig:quicksort}
\end{figure}
\textbf{Problem Statement:}\\
Sort the given array using Quicksort. Use Lomuto partition scheme, i.e. take the last element of array as pivot.
\begin{note}
	You are not provided with the size of array. Learn the way to do it! If you give up then go through procedure in starter code and understand it thoroughly.
\end{note}
\begin{testcases}
	{$t$ \hfill(number of test cases, an integer)\\
	$a_0\ a_1\ a_2 \cdots a_{n_i-1}$ \hfill($n_i$ space seperated integers for each testcase)}
	{Sorted Array\hfill(space seperated elements for each test case)}
	{$1\leq n_i \leq 1000, -100000\leq a_{i}\leq 100000$\hfill(integers)}
	{4\\
	1 7 5 2 3 10 4 6 9 8\\
	86 56 24 26 55 73 77 100 53 20 52 59 74 43 19 21 74 51 44 79 76 15 54 62 6 43 42 5 28 84\\
	17 9 10 6 6 12 5 16 18 1 14 11 6 12 14 12 13 10 12 3 2 16 16 14 11 12 7\\
	59 18 -85 99 87 -90 -17 -83 -28 -19 -39 46 -27 -20 53 48 -11 -42 5 85 -49 78 86 -42 -33 -56 -41 21 -62 95 -59 -63 50 57 78 -8 14 -35 -5 7 4 -45 -17 -10 -23}
	{1 2 3 4 5 6 7 8 9 10\\
	5 6 15 19 20 21 24 26 28 42 43 43 44 51 52 53 54 55 56 59 62 73 74 74 76 77 79 84 86 100\\
	1 2 3 5 6 6 6 7 9 10 10 11 11 12 12 12 12 12 13 14 14 14 16 16 16 17 18\\
	-90 -85 -83 -63 -62 -59 -56 -49 -45 -42 -42 -41 -39 -35 -33 -28 -27 -23 -20 -19 -17 -17 -11 -10 -8 -5 4 5 7 14 18 21 46 48 50 53 57 59 78 78 85 86 87 95 99}
	{https://github.com/paramrathour/CS-101/tree/main/Starter Codes/Quicksort.cpp}
\end{testcases}
\begin{funvideo}
	\href{https://youtu.be/WaNLJf8xzC4}{What's the fastest way to alphabetize your bookshelf? - Chand John -- TED-Ed}
\end{funvideo}
\KOMAoptions{paper=A4}
\recalctypearea