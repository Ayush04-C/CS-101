\section{Traditional Conditionals}
\begin{topics}
\verb!if else! statement, loop contol statements (\verb!break, continue!), more data types (\verb!bool, char!) and, \\logical NOT, AND, OR operators (\emph{\texttt{!, \&\&, ||}} respectively) and previous sections.
\end{topics}
\subsection{Triangle Types}
Triangles can be classified using sides and angles as follows:
\subsubsection{By Side}
\begin{description}
\item[Scalene] All sides different
\item[Isosceles] Any two sides equal
\item[Equilateral] All sides equal
\end{description}
\subsubsection{By Angle}
\begin{description}
\item[Acute] All angles $< 90$\textdegree
\item[Right] One angle $= 90$\textdegree
\item[Obtuse] One angle $> 90$\textdegree
\end{description}
\textbf{Problem Statement:}\\
Given the three sides of the triangle $a,b,c$, output the type of triangle by side and angle. Also check the validity of given sides i.e., output ``NOT A TRIANGLE'' if the given sides does not form a triangle.
\begin{testcases}
	{$t$ \hfill(number of test cases, an integer)\\
	$a_{i}\ b_{i}\ c_{i}$ \hfill(three space seperated integers for each testcase)}
	{Type by side \& Type by angle \hfill{(each test case on a newline)}}
	{$1 \leq a,b,c \leq 100$}
	{7\\1 2 3\\3 4 2\\5 3 4\\4 5 6\\3 3 2\\5 3 3\\3 3 3}
	{NOT A TRIANGLE\\Scalene \& Obtuse\\Scalene \& Right\\Scalene \& Acute\\Isosceles \&\ Acute\\Isosceles \& Obtuse\\Equilateral \& Acute}
	{https://github.com/paramrathour/CS-101/tree/main/Starter Codes/Triangle Type.cpp}
\end{testcases}
\subsection{Clock Angle}
\textbf{Problem Statement:}\\
Determine the pairwise angle between the hour, minute and second hand of a 24-hour clock at given time.
\\Let
\begin{itemize}
\item $\angle_{HM}$ denote angle between hour hand and minute hand.
\item $\angle_{HS}$ denote angle between hour hand and second hand.
\item $\angle_{MS}$ denote angle between minute hand and second hand.
\end{itemize}
\begin{note}
Calculate the convex angle between pair of hands i.e., $0\leq\angle_{ij}\leq180$.
\end{note}
\begin{testcasesMore}
	{$t$ \hfill(number of test cases, an integer)\\
	Hours:Minutes:Seconds \hfill(three colon seperated integers for each testcase)}
	{$\angle_{HM}\quad\angle_{HS}\quad\angle_{MS}$ \hfill{(three space seperated angles (in degrees, accurate till 4 decimal places)) on a newline}}
	{Given time is a valid; i.e., $0 \leq$ Hours $\leq 23$, $0 \leq$ Minutes $\leq 59$, $0 \leq$ Seconds $\leq 59$ \hfill(integers)}
	{12\\00:00:00\\03:00:00\\21:45:00\\10:10:00\\03:16:36\\09:49:09\\19:38:18\\05:07:11\\11:07:05\\17:19:23\\23:19:17\\23:59:59}
	{0.0000\quad0.0000\quad0.0000\\90.0000\quad90.0000\quad0.0000\\22.5000\quad67.5000\quad90.0000\\115.0000\quad55.0000\quad60.0000\\1.3000\quad117.7000\quad116.4000\\0.3250\quad119.4250\quad119.1000\\0.6500\quad121.1500\quad121.8000\\110.4917\quad87.5917\quad22.9000\\68.9583\quad56.4583\quad12.5000\\43.3917\quad21.6917\quad21.7000\\136.0583\quad122.3583\quad13.7000\\0.0917\quad5.9917\quad5.9000}
	{https://github.com/paramrathour/CS-101/tree/main/Test Cases/Clock Angle/Input.txt}
	{https://github.com/paramrathour/CS-101/tree/main/Test Cases/Clock Angle/Output.txt}
	{https://github.com/paramrathour/CS-101/tree/main/Starter Codes/Clock Angle.cpp}
\end{testcasesMore}
\subsection{Fleur Delacour}
Fleur Delacour has an interesting flower. She is also very busy, so  she forgets to water the flower sometimes.\\
The flower grows as follows:
\begin{itemize}
\item If the flower is watered in the $i$-th day, it grows by 1 unit.
\item If the flower is watered in the $i$-th and in the $(i-1)$-th day $(i>1)$, then it grows by 5 units instead of 1.
\item If the flower is not watered in the $i$-th day, it does not grow.
\item If the flower isn't watered for two days in a row, it dies.
\end{itemize}
\textbf{Problem Statement:}\\
Calculate the flower's height after $n$ days given information whether Fleur has watered the flower or not for $n$ successive days. Take the flower's initial height as 1 unit.
\begin{testcasesMore}
	{$t$ \hfill(number of test cases, an integer)\\
	$n_i\quad a_{1}\ a_{2}\ \ldots\ a_{n_{i-1}}\ a_{n_i}$ \hfill($n_i+1$ space seperated integers for each testcase)}
	{The flower's height after $n_i$ days. If the flower dies, output $-1$ \hfill(each test case on a newline)}
	{$1 \leq n_i \leq 100$\\[0.5em]
	$
	a_i = \begin{cases} 
      1 & \text{if Fleur waters the flower}\\
      0 & \text{if Fleur does not water the flower}
   \end{cases}
	$}
	{9\\1\quad0\\2\quad0 0\\2\quad1 0\\3\quad1 0 1\\3\quad0 1 1\\5\quad1 0 1 0 0\\5\quad1 0 1 0 1\\5\quad1 0 1 1 0\\10\quad1 1 1 1 1 1 1 1 1 1}
	{1\\-1\\2\\3\\7\\-1\\4\\8\\47}
	{https://github.com/paramrathour/CS-101/tree/main/Test Cases/Fleur Delacour/Input.txt}
	{https://github.com/paramrathour/CS-101/tree/main/Test Cases/Fleur Delacour/Output.txt}
	{https://github.com/paramrathour/CS-101/tree/main/Starter Codes/Fleur Delacour.cpp}
\end{testcasesMore}
\begin{note}
	Verify your program on even more testcases from \href{https://codeforces.com/problemset/problem/1585/A}{here}.
\end{note}
% \subsection{$L^p$-norm}
% The $L^p$-norm $(p\geq1)$ of a vector $x = (x_1, x_2,\ldots, x_n)$ is defined by
% \begin{equation}
% {\displaystyle \left\|x\right\|_{p}=\left(|x_{1}|^{p}+|x_{2}|^{p}+\dotsb +|x_{n}|^{p}\right)^{1/p}\quad\text{and}\quad \left\|x\right\|_{\infty}=\displaystyle\lim_{p\rightarrow\infty}\left\|x\right\|_{p}}
% \end{equation}
% where $\left\|x\right\|_{p}$ is the $L^\infty$-norm a.k.a. maximum norm or uniform norm.\\
% \textbf{Problem Statement:}\\
% Calculate $\left\|x\right\|_p$ for a given vector for all test cases accurate till 5 decimal places
% \begin{testcases}
% 	{$t$ \hfill(number of test cases, an integer)\\
% 	$p_i\qquad n_i\quad x_1\ x_2\ \ldots x_{n_i-1}\ x_{n_i}$ \hfill($n_i+2$ space seperated numbers for each testcase)\\
% 	As using the $\infty$ symbol is bit convoluted, we will use $p_i = 0$ to denote maximum norm}
% 	{$\left\|x\right\|_{p_i}$ \hfill{(each test case on a newline)}}
% 	{$1 \leq p_i \leq \infty$, \hfill{(a double)}\\
% 	$1 \leq n_i \leq 20$, \hfill{(an integer)}\\
% 	$\op{abs}(x_i) \leq 100$, \hfill{(a double)}\\
% 	Also assume that the calculations are always within the range of double}
% 	{11\\0\qquad4\quad1 1 1 1\\1\qquad4\quad1 1 1 1\\2\qquad4\quad1 1 1 1\\3\qquad4\quad1 1 1 1\\4\qquad4\quad1 1 1 1\\0\qquad12\quad-8 5 -3 2 -1 1 0 1 1 2 3 5\\1\qquad12\quad-8 5 -3 2 -1 1 0 1 1 2 3 5\\2\qquad12\quad-8 5 -3 2 -1 1 0 1 1 2 3 5\\2.71828\qquad12\quad-8 5 -3 2 -1 1 0 1 1 2 3 5\\3.14159\qquad12\quad-8 5 -3 2 -1 1 0 1 1 2 3 5\\3\qquad14\quad1.5 9.2 6.5 3.5 8.9 7.9 3.2 3.8 4.6 2.6 4.3 3.8 3.2 7.9}
% 	{1.00000\\4.00000\\2.00000\\1.58740\\1.41421\\8.00000\\32.00000\\12.00000\\9.84251\\9.25415\\14.67495}
% 	{https://github.com/paramrathour/CS-101/tree/main/Starter Codes/Lp norm.cpp}
% \end{testcases}
\subsection{ISBN}
You may have wondered about the 10 (or 13) digits numbers on the back of every book. They are ISBN, which stands for International Standard Book Number and is used for uniquely identifying books and other publications (including e-publications). Go find the ISBN of your favourite book! :)\\
Let us consider ISBN 10 (10 digit numbers), an old format that got replaced by ISBN 13.
The first 9 digits contain information about the geographical region, publisher and edition of the title. The last digit is a check digit used for validating the number.
Let the number be $x_1x_2x_3x_4x_5x_6x_7x_8x_9x_{10}$, then the check digit $x_{10}$ is chosen such that the checksum $= 10x_1 + 9x_2 + 8x_3 + 7x_4 + 6x_5 + 5x_6 + 4x_7 + 3x_8 + 2x_9 + 1x_{10}$ is a multiple of 11.
This condition is succinctly represented as below:
\begin{equation}
{\displaystyle \left(\sum _{i=1}^{10}(11-i)x_{i} \right) \% 11 = 0}
\end{equation}
\subsubsection{Generation of check digit (example)}
If the first nine digits are 812913572 then $8\times10 + 1\times9 + 2\times8 + 9\times7 + 1\times6 + 3\times5 + 5\times4 + 7\times3 + 2\times2 = 234$. So if $x_{10} = 8$, then the checksum is divisible by 11. Hence, the ISBN is 8129135728.
\begin{note}
It as possible that the calculated check digit is 10 as we can get any remainder from 0 to 10 when divided by 11. But when the remainder is 10, as is not a single digit, appending 10 to ISBN will make its length 11. To avoid such cases, the letter `X' is used to denote check digit = 10.
\end{note}
\textbf{Problem Statement:}\\
Recover and output the missing digit from a given valid ISBN 10 code with a digit erased.\\
The missing digit can be any $x_i$ $(1\leq i\leq 10)$.
\begin{testcases}
	{$t$ \hfill(number of test cases, an integer)\\
	10 characters each either representing a digit (0-9) or a missing number (‘?’).\hfill(for each testcase)\\
	The last character (check digit) can also be `X'.}
	{A single digit, that is to be placed at `?' position to make the given ISBN valid.
 \hfill{(space seperated)}\\
	If the missing integer is 10 then, the output should be `X'}
	{It is always possible that a unique ISBN exists. (Why?)}
	{9\\81291?5728\\30303935?7\\366205414?\\366?054140\\05?0764845\\?590764845\\?43935806X\\933290152?\\9332?0152X}
	{3 7 0 2 9 0 0 X 9}
	% {10\\81291?5728\\366205414?\\05907?4845\\0?90353403\\?43935806X\\303039357?\\02015?8025\\?201558025\\933290152?\\9332?0152X}
	% {0\\6\\5\\0\\3\\7\\5\\0\\X\\9}
	{https://github.com/paramrathour/CS-101/tree/main/Starter Codes/ISBN.cpp}
\end{testcases}
\begin{funvideo}
\href{https://youtu.be/sPFWfAxIiwg}{11.11.11 -- Numberphile}
\end{funvideo}
\subsection{Doomsday Algorithm}
The Doomsday Algorithm is a method for determining the day of the week for a given date. It  takes advantage of some easy-to-remember-dates called \emph{Doomsdates} falling on the same day called \emph{Doomsdays} for a given year.\\
Eg., 3/1 (4/1 leap years), Last Day of Feb, 14/3 (Pi Day), 4/4, 6/6, 8/8, 10/10, 12/12, 9/5, 5/9, 11/7, 7/11.
% \subsubsection{The Algorithm}

Watch the \href{https://youtu.be/z2x3SSBVGJU}{Fun Video} or go through the \href{https://en.wikipedia.org/wiki/Doomsday_rule}{Wikipedia Article} to understand the approach. In short the steps are:
\begin{itemize}
\item Find the anchor day for the century.
\item Calculate the anchor day for the year (according to the century).
\item Select the date (\emph{Doomsdate}) of the given month that falls on doomsday (according to the year).
\item Count days between the \emph{Doomsdate} and given date which gives the answer.
\end{itemize}
\textbf{Problem Statement:}\\
Write a function that calculates the day of the week for any particular date in the past or future.\\
Consider Gregorian calendar (AD)
\begin{testcasesMore}
	{$t$ \hfill(number of test cases, an integer)\\
	DD/MM/YYYY (Date Month Year)\hfill(three slash seperated integers for each testcase)}
	{Day of the Week
 \hfill{(each test case on a newline)}}
	{$1 \leq$ Date $\leq 99$, $1 \leq$ Month $\leq 99$, $1 \leq$ Year $\leq 9999$ \hfill(integers)}
	{8\\01/01/0001\\19/02/1627\\29/02/1700\\15/04/1707\\22/12/1887\\23/06/1912\\01/01/2000\\15/03/2020}
	{Monday\\Friday\\INVALID DATE!\\Friday\\Thursday\\Sunday\\Saturday\\Sunday}
	% {10\\81291?5728\\366205414?\\05907?4845\\0?90353403\\?43935806X\\303039357?\\02015?8025\\?201558025\\933290152?\\9332?0152X}
	% {0\\6\\5\\0\\3\\7\\5\\0\\X\\9}
	{https://github.com/paramrathour/CS-101/tree/main/Test Cases/Doomsday Algorithm/Input.txt}
	{https://github.com/paramrathour/CS-101/tree/main/Test Cases/Doomsday Algorithm/Output.txt}
	{https://github.com/paramrathour/CS-101/tree/main/Starter Codes/Doomsday Algorithm.cpp}
\end{testcasesMore}
\begin{funvideo}{\label{sec:fvdoomsday}}
\href{https://youtu.be/z2x3SSBVGJU}{The Doomsday Algorithm -- Numberphile}
\end{funvideo}